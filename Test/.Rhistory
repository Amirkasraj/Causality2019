r = max(r,max(x))
}
C[[c]] = generate.C(pdfs,l,r,power)
}
difference(C)
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 6:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
distance <- function(a,b) {
n = length(a)
I = n/10
ans = 1e20
for (i in -I:I) {
l = max(1,i)
r = min(n,n+i)
a.shifted = a[l:r]
null = vector('numeric',n-(r-l))
if (i > 0) a.shifted = c(null,a.shifted)
else a.shifted = c(a.shifted,null)
ans = min(ans, kl(a.shifted,b))
}
ans
}
distance <- function(a,b) {
n = length(a)
I = n/10
ans = 1e20
for (i in -I:I) {
l = max(1,i)
r = min(n,n+i)
a.shifted = a[l:r]
null = vector('numeric',n-(r-l))
if (i > 0) a.shifted = c(null,a.shifted)
else a.shifted = c(a.shifted,null)
ans = min(ans, kl(a.shifted,b))
}
ans
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
# f : [-0.5,0.5] -> [0,inf]
generate.f <- function(complexity = 5) {
l = -0.5
r = 0.5
x = seq(from = l, to = r,length.out = complexity)
normal = rnorm(complexity)
pos = exp(normal)
f = splinefun(pos~x)
u = seq(from = l, to=r, length.out = 1000)
shift = -min(f(u)) + 0.5
scale = 1/(integrate(f,lower = l,upper = r)$value+shift*(r-l))
function(x) {
ans = vapply(FUN = f,X = x,FUN.VALUE = 1)
(ans + shift)*scale
}
}
indefinite_integral = function(f) {
my_integral <- function(x) {
integrate(f,lower = -0.5,upper = x)$value
}
function(x) {
vapply(FUN = my_integral,X = x,FUN.VALUE = 1)
}
}
library(sigmoid)
projection <- function(x) {
#x/(1+abs(x)) * (0.5/1)
sigmoid(x)-0.5
}
generate.F <- function(...) {
f = generate.f(...)
F = indefinite_integral(f)
#curve(F,xlim = c(-0.5,0.5))
function(x) {
F(projection(x))
}
}
generate.weights <- function(x,l) {
l = abs(l-x)
l = 1/(l^2+0.00000001)
l/sum(l)
}
combination <- function(functions, weights) {
n = length(functions)
function(e) {
ans = 0
for (i in 1:n)
ans = ans + functions[[i]](e)*weights[i]
ans
}
}
generate.mechanism <- function(stations.x) {
n = length(stations.x)
functions = vector()
for (i in 1:n)
functions = c(functions,generate.F())
#for (i in 1:length(stations.x)) {
#  F  = stations[[i]]
#  curve(F,add = (i!=1),xlim = c(-3,3))
#}
#print(stations.x)
function(x,e) {
weights = generate.weights(x,stations.x)
combination(functions,weights)(e)
}
}
generate.data <- function(n=10000, groups=2, anticausal = FALSE, vars = 1:groups) {
f = generate.mechanism(seq(from = -1, to = 1, length.out = 3))
res = list(groups)
for (g in 1:groups) {
X = rnorm(n,sd = 1)
E = rnorm(n,sd = vars[g],mean = (g-1.5)/2)#runif(1,05,2))
#print(sqrt(var(E)))
Y = mapply(FUN = f, x = X, e = E)
res[[g]] = data.frame(x = X,y = Y)
}
if (anticausal)
res = reverse.data(res)
res
}
reverse.data <- function(D) {
groups = length(D)
res = D
for (g in 1:groups) {
names(res[[g]])[names(res[[g]]) == "x"] = "z"
names(res[[g]])[names(res[[g]]) == "y"] = "x"
names(res[[g]])[names(res[[g]]) == "z"] = "y"
}
res
}
generate.coditions <- function(Xs, k = 7) {
# ToDo interval should be small ?! use hdr
m = mean(Xs[[1]])
s = sqrt(var(Xs[[1]]))
seq(from = m-1*s, to = m+1*s, length.out = k)
}
average <-function(functions) {
function(x) {
ans = 0
for (f in functions)
ans = ans + f(x)
ans
}
}
generate.cdf <- function(xs,ys) {
l=min(xs)
r=max(xs)
d = splinefun(xs,ys)
i = integrate(d,lower = l ,upper = r)$value
single <- function(x) {
y = 0
if (x<l) y = 0
else if (x>r) y = 1
else y = integrate(d,lower = l, upper = x)$value
y/i
}
function(x) {
vapply(FUN = single, X=x, FUN.VALUE = 1)
}
}
generate.pdf <- function(xs,ys) {
l=min(xs)
r=max(xs)
d = splinefun(xs,ys)
i = integrate(d,lower = l ,upper = r)$value
single <- function(x) {
y = 0
if (x<l) y = 0
else if (x>r) y = 0
else y = d(x)
y/i
}
function(x) {
vapply(FUN = single, X=x, FUN.VALUE = 1)
}
}
generate.sample <- function(distribution,n=1) {
u = runif(n,min = 0,max = 1)
root <- function(a) {
uniroot(function(x){distribution(x) - a},interval = c(-1000,1000))$root
}
vapply(FUN = root, X = u, FUN.VALUE = 1)
}
phi <-function(pdfs,x) {
single <- function(x) {
ans = NULL
for (d in pdfs)
ans = c(ans, d(x))
ans
}
vapply(FUN = single,X = x,FUN.VALUE = double(length = length(pdfs)))
}
generate.C <- function(pdfs, cdfs, n=1000, ref=average(cdfs)){
groups = length(pdfs)
points = generate.sample(ref,n)
samples = phi(cdfs,points)
s = 0
for (g in 1:groups)
s = s + samples[g,]
for (g in 1:groups)
samples[g,] = samples[g,]/s
#assume groups = 2
sqrt((1-samples[1,])^2 + samples[2,]^2)/sqrt(2)
}
library(hdrcde)
library(KernSmooth)
bootstrap <- function(x,iter = 10*length(x),gridsize=1000) {
xs = NULL
for (b in 1:iter) {
smpl = sample(x,length(x),replace = T)
l = 0.1
r = 0.9
dens = bkde(smpl,range.x = c(l,r),gridsize = gridsize, truncate = T,kernel = 'box')
ys = dens$y
xs = dens$x
ys[ys<0.00000001] = 0
ys = dens$y
ys = ys/mean(ys)
avg = avg + ys
}
avg/iter
}
distance <- function(a,b) {
mean(a*(log(a)-log(b)) + b*(log(b)-log(a)))
}
difference <- function(h) {
groups = length(h)
ans = 0
for (i in 1:groups)
for (j in 1:groups)
ans = max(ans,distance(h[[i]],h[[j]]))
ans
}
library(KernSmooth)
library(hdrcde)
library(KernSmooth)
library(hdrcde)
identification <- function(D) {
groups = length(D)
Xs = list(groups)
for (g in 1:groups){
Xs[[g]] = D[[g]]$x
s = sqrt(var(D[[g]]$x))
m = mean(D[[g]]$x)
D[[g]] = D[[g]][abs(D[[g]]$x-m) < 1.5*s,]
}
conditions = generate.coditions(Xs)
cdes = list(groups)
for (g in 1:groups) {
for (condition in conditions) {
cdes[[g]] = cde(D[[g]]$x,D[[g]]$y,x.margin = conditions,rescale = T,nymargin = 1000)
}
}
cdes.length = length(cdes[[1]]$z[1,])
n=300
# :(
Cs = data.frame(sample = 1:n)
Cs = Cs[-1]
K = length(conditions)
for (c in 1:K) {
pdfs = list(groups)
cdfs = list(groups)
for (g in 1:groups) {
pdfs[[g]] = generate.pdf(cdes[[g]]$y, cdes[[g]]$z[c,])
cdfs[[g]] = generate.cdf(cdes[[g]]$y, cdes[[g]]$z[c,])
}
C =  generate.C(pdfs,cdfs,n)
Cs[[c]] = C
}
avg = 0
# :(
h = data.frame(sample = 1:1000)
h = h[-1]
for (c in 1:K) {
x = as.vector(Cs[[c]])
h[[c]] = bootstrap(x)
avg = avg + h[[c]]
}
difference(h)
}
library(Rlab)
test.size = 100
set.seed(102)
test.answer = rbern(n = 100,prob = 0.5)
test.answer = as.logical(test.answer)
mean(test.answer)
test.size = 100
set.seed(102)
test.answer = rbern(n = 100,prob = 0.5)
test.answer = as.logical(test.answer)
mean(test.answer)
D = vector("list",test.size)
for (t in 1:test.size) {
d = generate.data(n=1000,anticausal = test.answer[t], vars = c(0.2,0.6))
D[[t]] = d
}
for (t in 1:test.size) {
grDevices::pdf(paste("synthetic/",as.character(t),".pdf",sep = ""))
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,cex = 0.4,pch = 16, col= "blue")
points(d[[1]]$y~d[[1]]$x,cex = 0.4,pch = 16,col = "red")
dev.off()
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
for (t in 1:test.size) {
grDevices::pdf(paste("synthetic/",as.character(t),".pdf",sep = ""))
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,cex = 0.4,pch = 16, col= "black")
points(d[[1]]$y~d[[1]]$x,cex = 0.4,pch = 16,col = "red")
dev.off()
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
hist(test.causal[!test.answer],breaks = 100,xlim = c(min(test.causal),max(test.causal)))
hist(test.causal[test.answer],breaks = 100,xlim = c(min(test.causal),max(test.causal)))
test.tresh = 6
test.classifier = test.causal > test.tresh
table(test.classifier, test.answer)
mean(test.classifier*test.answer + (!test.classifier)*(!test.answer))
test.directions = test.causal > test.anticausal
table(test.directions, test.answer)
mean(test.directions*test.answer + (!test.directions)*(!test.answer))
<-
generate.coditions <- function(Xs, k = 7) {
# ToDo interval should be small ?! use hdr
m = mean(Xs[[1]])
s = sqrt(var(Xs[[1]]))
seq(from = m-1*s, to = m+1*s, length.out = k)
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
hist(test.causal[!test.answer],breaks = 100,xlim = c(min(test.causal),max(test.causal)))
hist(test.causal[test.answer],breaks = 100,xlim = c(min(test.causal),max(test.causal)))
test.tresh = 6
test.classifier = test.causal > test.tresh
table(test.classifier, test.answer)
mean(test.classifier*test.answer + (!test.classifier)*(!test.answer))
test.directions = test.causal > test.anticausal
table(test.directions, test.answer)
mean(test.directions*test.answer + (!test.directions)*(!test.answer))
generate.coditions <- function(Xs, k = 7) {
# ToDo interval should be small ?! use hdr
m = mean(Xs[[1]])
s = sqrt(var(Xs[[1]]))
seq(from = m-1*s, to = m+1*s, length.out = k)
}
average <-function(functions) {
function(x) {
ans = 0
for (f in functions)
ans = ans + f(x)
ans
}
}
generate.data <- function(n=10000, groups=2, anticausal = FALSE, vars = 1:groups) {
f = generate.mechanism(seq(from = -1, to = 1, length.out = 3))
res = list(groups)
for (g in 1:groups) {
X = rnorm(n,sd = 1)
E = rnorm(n,sd = vars[g],mean = 0)#runif(1,05,2))
#print(sqrt(var(E)))
Y = mapply(FUN = f, x = X, e = E)
res[[g]] = data.frame(x = X,y = Y)
}
if (anticausal)
res = reverse.data(res)
res
}
test.size = 100
set.seed(102)
test.answer = rbern(n = 100,prob = 0.5)
test.answer = as.logical(test.answer)
mean(test.answer)
D = vector("list",test.size)
for (t in 1:test.size) {
d = generate.data(n=1000,anticausal = test.answer[t], vars = c(0.2,0.6))
D[[t]] = d
}
for (t in 1:test.size) {
grDevices::pdf(paste("synthetic/",as.character(t),".pdf",sep = ""))
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,cex = 0.4,pch = 16, col= "black")
points(d[[1]]$y~d[[1]]$x,cex = 0.4,pch = 16,col = "red")
dev.off()
}
test.causal = vector(length = test.size)
test.anticausal = vector(length = test.size)
for (t in 1:test.size) {
print(t)
d = D[[t]]
plot(d[[2]]$y~d[[2]]$x,pch = 16, cex = 0.4)
points(d[[1]]$y~d[[1]]$x,pch = 16, cex = 0.4,col = 'red')
if (test.answer[t]) print("anticausal")
else print("causal")
causal = identification(d)
print(causal)
anticausal = identification(reverse.data(d))
print(anticausal)
test.causal[t] = causal
test.anticausal[t] = anticausal
print("=======")
}
